	in      r1, r0             ; Read matrix dimension (n) from input into r1
	ld      r6, 0x2000         ; Load base address for Matrix A into r6
	ld      r7, 0x3000         ; Load base address for Matrix B into r7
	ld      r8, 0x4000         ; Load base address for Matrix C into r8
	clr     r2                 ; Clear r2: initialize row index for Matrix A

:A_loop
	ld      r16, :A_body       ; Load address of :A_body into r16
	brgt    r16, r1, r2        ; If n > current row (r2), branch to :A_body
	ld      r16, :B_read_start ; Otherwise, all rows read; jump to reading Matrix B
	br      r16

:A_body
	clr     r3                 ; Clear r3: initialize column index for current row in A

:A_inner
	ld      r16, :A_inner_body ; Load address of :A_inner_body into r16
	brgt    r16, r1, r3        ; If n > current column (r3), branch to :A_inner_body
	addi    r2, 1              ; Else, finished row: increment row index r2
	ld      r16, :A_loop       ; Jump back to :A_loop to process next row
	br      r16

:A_inner_body
	mul     r9, r2, r1         ; Compute offset = row_index * n
	add     r9, r9, r3         ; Add column index: offset = (row_index * n + col_index)
	shftli  r9, 3              ; Multiply offset by 8 (<< 3) for 8-byte alignment
	add     r9, r6, r9         ; Add base address for A to get effective address of A[i][j]
	in      r10, r0            ; Read element value from input into r10
	mov     (r9)(0), r10       ; Store value at computed memory address for A[i][j]
	addi    r3, 1              ; Increment column index for Matrix A
	ld      r16, :A_inner      ; Branch back to inner loop for next element in row
	br      r16

:B_read_start
	clr     r2                 ; Clear r2: initialize row index for Matrix B

:B_loop
	ld      r16, :B_body       ; Load address of :B_body into r16
	brgt    r16, r1, r2        ; If n > current row (r2), branch to :B_body
	ld      r16, :Multiply_start ; Else, finished reading B; jump to multiplication phase
	br      r16

:B_body
	clr     r3                 ; Clear r3: initialize column index for current row in B

:B_inner
	ld      r16, :B_inner_body ; Load address of :B_inner_body into r16
	brgt    r16, r1, r3        ; If n > current column (r3), branch to :B_inner_body
	addi    r2, 1              ; Else, finished row: increment row index for B
	ld      r16, :B_loop       ; Branch back to outer loop for Matrix B
	br      r16

:B_inner_body
	mul     r9, r2, r1         ; Compute offset = row_index * n for B
	add     r9, r9, r3         ; Add column index: offset = (row_index * n + col_index)
	shftli  r9, 3              ; Multiply offset by 8 for 8-byte alignment
	add     r9, r7, r9         ; Add base address for B to get effective address of B[i][j]
	in      r10, r0            ; Read element value from input into r10
	mov     (r9)(0), r10       ; Store value at computed memory address for B[i][j]
	addi    r3, 1              ; Increment column index for Matrix B
	ld      r16, :B_inner      ; Branch back to inner loop for next element in row
	br      r16

:Multiply_start
	clr     r2                 ; Clear r2: initialize row index for matrix multiplication (result matrix C)

:M_loop
	ld      r16, :M_body       ; Load address of :M_body into r16
	brgt    r16, r1, r2        ; If n > current row (r2), branch to :M_body
	ld      r16, :Output_start ; Else, finished multiplication; jump to output phase
	br      r16

:M_body
	mov     r15, r2            ; Save current row index (r2) into r15 for use in dot product
	clr     r3                 ; Clear r3: initialize column index for result matrix C

:M_inner
	ld      r16, :M_inner_body ; Load address of :M_inner_body into r16
	brgt    r16, r1, r3        ; If n > current column (r3), branch to :M_inner_body
	addi    r2, 1              ; Else, finished current row; increment row index r2
	ld      r16, :M_loop       ; Branch back to outer multiplication loop
	br      r16

:M_inner_body
	clr     r5                 ; Clear accumulator r5 for dot product result for C[i][j]
	clr     r4                 ; Clear inner loop counter r4 (k index)

:K_loop
	ld      r16, :K_body       ; Load address of :K_body into r16
	brgt    r16, r1, r4        ; If n > current k (r4), branch to :K_body
	ld      r16, :Store_C      ; Else, finished inner loop; branch to store the result in C
	br      r16

:K_body
	mul     r9, r15, r1        ; Compute offset for A[r15][k] = r15 * n
	add     r9, r9, r4         ; Add k index: offset = (r15 * n + k)
	shftli  r9, 3              ; Multiply offset by 8 for alignment
	add     r9, r6, r9         ; Add base address for A to get effective address of A[r15][k]
	mov     r11, (r9)(0)       ; Load value of A[r15][k] into r11
	mul     r12, r4, r1        ; Compute offset for B[k][j] = k * n
	add     r12, r12, r3       ; Add current column index (j): offset = (k * n + j)
	shftli  r12, 3             ; Multiply offset by 8 for alignment
	add     r12, r7, r12       ; Add base address for B to get effective address of B[k][j]
	mov     r13, (r12)(0)      ; Load value of B[k][j] into r13
	mulf    r14, r11, r13      ; Multiply A[r15][k] * B[k][j] (floating-point multiplication)
	addf    r5, r5, r14        ; Accumulate product into r5
	addi    r4, 1              ; Increment k (inner loop counter)
	ld      r16, :K_loop       ; Branch back to :K_loop for next k value
	br      r16

:Store_C
	mul     r9, r15, r1        ; Compute offset for C[r15][j] = r15 * n
	add     r9, r9, r3         ; Add current column index (j)
	shftli  r9, 3              ; Multiply offset by 8 for alignment
	add     r9, r8, r9         ; Add base address for C to get effective address of C[r15][j]
	mov     (r9)(0), r5        ; Store the computed dot product from r5 into C[r15][j]
	addi    r3, 1              ; Increment column index for result matrix C
	ld      r16, :M_inner      ; Branch back to :M_inner to process next element in the row
	br      r16

:Output_start
	clr     r2                 ; Clear r2: initialize row index for output phase

:O_outer
	ld      r16, :O_body       ; Load address of :O_body into r16
	brgt    r16, r1, r2        ; If n > current row (r2), branch to :O_body to output that row
	ld      r16, :Halt_program ; Else, finished output; branch to halt
	br      r16

:O_body
	clr     r3                 ; Clear r3: initialize column index for output in current row

:O_inner
	ld      r16, :O_inner_body ; Load address of :O_inner_body into r16
	brgt    r16, r1, r3        ; If n > current column (r3), branch to :O_inner_body for outputting element
	addi    r2, 1              ; Else, finished current row; increment row index (r2)
	ld      r16, :O_outer       ; Branch back to :O_outer for next row
	br      r16

:O_inner_body
	mul     r9, r2, r1         ; Compute offset for C[r2][j] = r2 * n
	add     r9, r9, r3         ; Add column index (j)
	shftli  r9, 3              ; Multiply offset by 8 for alignment
	add     r9, r8, r9         ; Add base address for C to get effective address of C[r2][j]
	mov     r10, (r9)(0)       ; Load element C[r2][j] into r10
	ld      r11, 1             ; Load constant 1 into r11 (output port number)
	out     r11, r10           ; Output the value of C[r2][j] to the console
	addi    r3, 1              ; Increment column index for output
	ld      r16, :O_inner      ; Branch back to :O_inner for next element in the row
	br      r16

:Halt_program
	priv    r0, r0, r0, 0x0     ; Halt the processor (stop simulation)
